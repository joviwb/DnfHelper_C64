#include "pch.h"


地图数据 寻路_地图数据()
{
	地图数据 局_地图数据;
	ULONG64 局_房间数据 = 读写_读长整数(读写_读长整数(读写_读长整数(房间编号) + 时间基址) + 门型偏移);
	ULONG64 局_房间索引 = 全局_收包数据.参_地图序号;
	局_地图数据.宽 = 读写_读整数型(读写_读长整数(局_房间数据 + 宽高偏移) + 局_房间索引 * 8);
	局_地图数据.高 = 读写_读整数型(读写_读长整数(局_房间数据 + 宽高偏移) + 局_房间索引 * 8 + 4);
	局_地图数据.临时变量 = 读写_读长整数(读写_读长整数(局_房间数据 + 通道偏移) + 40 * 局_房间索引 + 8);
	局_地图数据.通道数量 = 局_地图数据.宽 * 局_地图数据.高;
	for (size_t i = 0; i < 局_地图数据.通道数量; i++)
	{
		局_地图数据.地图通道.insert(局_地图数据.地图通道.begin() + i, 读写_读整数型(局_地图数据.临时变量 + i * 4));
	}
	局_地图数据.起始坐标.X = 全局_收包数据.参_当前坐标.参_横轴坐标 + 1;
	局_地图数据.起始坐标.Y = 全局_收包数据.参_当前坐标.参_纵轴坐标 + 1;
	局_地图数据.终点坐标.X = 全局_收包数据.参_领主坐标.参_横轴坐标 + 1;
	局_地图数据.终点坐标.Y = 全局_收包数据.参_领主坐标.参_纵轴坐标 + 1;
	if (坐标相等(局_地图数据.起始坐标, 局_地图数据.终点坐标))
	{
		return 局_地图数据;
	}
	局_地图数据.消耗疲劳 = 寻路_获取走法(局_地图数据.地图通道, 局_地图数据.宽, 局_地图数据.高, 局_地图数据.起始坐标, 局_地图数据.终点坐标, 局_地图数据.地图走法);
	return 局_地图数据;
}

DWORD 寻路_获取走法(vector<DWORD> 参_地图通道, DWORD 参_宽度, DWORD 参_高度, 坐标型 参_地图起点, 坐标型 参_地图终点, vector<坐标型>& 参_真实走法)
{
	坐标型 start_coordinate;
	坐标型 end_coordinate;
	vector<vector<游戏地图>> map_flag;
	vector<vector<游戏地图>> map_array;
	vector<坐标型> cross_way;

	if (参_地图起点.X == 参_地图终点.X && 参_地图起点.Y == 参_地图终点.Y)
	{
		参_真实走法.clear();
		参_真实走法.resize(0);
		return 0;
	}
	寻路_生成地图(参_宽度, 参_高度, 参_地图通道, map_array);
	寻路_显示地图(map_array, 参_宽度, 参_高度, map_flag);
	start_coordinate.X = 参_地图起点.X * 3 - 2;
	start_coordinate.Y = 参_地图起点.Y * 3 - 2;
	end_coordinate.X = 参_地图终点.X * 3 - 2;
	end_coordinate.Y = 参_地图终点.Y * 3 - 2;
	寻路_路径算法(map_flag, start_coordinate, end_coordinate, 参_宽度 * 3, 参_高度 * 3, cross_way);
	return 寻路_整理坐标(cross_way, 参_真实走法);

}

VOID 寻路_生成地图(DWORD 参_宽度, DWORD 参_高度, vector<DWORD> 参_地图通道, vector<vector<游戏地图>>& 参_游戏地图)
{
	参_游戏地图.clear();
	参_游戏地图.resize(参_宽度);
	for (int x = 0; x < 参_宽度; x++)
	{
		参_游戏地图[x].resize(参_高度);
	}
	int i = 0;
	for (int y = 0; y < 参_高度; y++)
	{
		for (int x = 0; x < 参_宽度; x++)
		{
			参_游戏地图[x][y].地图坐标.X = x;
			参_游戏地图[x][y].地图坐标.Y = y;
			参_游戏地图[x][y].地图通道 = 参_地图通道[i];
			参_游戏地图[x][y].地图左边 = 寻路_判断方向(参_地图通道[i], 0);
			参_游戏地图[x][y].地图右边 = 寻路_判断方向(参_地图通道[i], 1);
			参_游戏地图[x][y].地图上边 = 寻路_判断方向(参_地图通道[i], 2);
			参_游戏地图[x][y].地图下边 = 寻路_判断方向(参_地图通道[i], 3);
			参_游戏地图[x][y].背景颜色 = 0xFFFFFF;
			i++;
			if (参_游戏地图[x][y].地图通道 == 0)
				参_游戏地图[x][y].背景颜色 = 0x000000;
		}
	}

}

VOID 寻路_显示地图(vector<vector<游戏地图>> 参_地图数组, DWORD 参_宽度, DWORD 参_高度, vector<vector<游戏地图>>& 参_地图标签)
{

	参_地图标签.clear();
	参_地图标签.resize(参_宽度 * 3);
	for (int x = 0; x < 参_宽度 * 3; x++)
	{
		参_地图标签[x].resize(参_高度 * 3);
	}
	for (int y = 0; y < 参_高度; y++)
	{
		for (int x = 0; x < 参_宽度; x++)
		{
			参_地图标签[(x + 1) * 3 - 2][(y + 1) * 3 - 2].背景颜色 = 0xFFFFFF;
			if (参_地图数组[x][y].地图左边)
				参_地图标签[(x + 1) * 3 - 3][(y + 1) * 3 - 2].背景颜色 = 0xFFFFFF;
			if (参_地图数组[x][y].地图右边)
				参_地图标签[(x + 1) * 3 - 1][(y + 1) * 3 - 2].背景颜色 = 0xFFFFFF;
			if (参_地图数组[x][y].地图上边)
				参_地图标签[(x + 1) * 3 - 2][(y + 1) * 3 - 3].背景颜色 = 0xFFFFFF;
			if (参_地图数组[x][y].地图下边)
				参_地图标签[(x + 1) * 3 - 2][(y + 1) * 3 - 1].背景颜色 = 0xFFFFFF;
		}
	}

}

VOID 寻路_路径算法(vector<vector<游戏地图>> 参_地图标签, 坐标型 参_地图起点, 坐标型 参_地图终点, DWORD 参_宽度, DWORD 参_高度, vector<坐标型>& 参_走法数组)
{
	BOOL 已存在开放列表, 已存在关闭列表;
	坐标型 待检测坐标;
	地图节点 待检测节点, 临时节点;
	vector<地图节点> 开放列表, 关闭列表;
	DWORD 最短编号 = 0;
	DWORD 最小F值, 预测G值;
	DWORD x, y;

	临时节点.当前坐标.X = 参_地图起点.X;
	临时节点.当前坐标.Y = 参_地图起点.Y;
	参_地图标签[参_地图起点.X][参_地图起点.Y].背景颜色 = 0x00FF00;
	参_地图标签[参_地图终点.X][参_地图终点.Y].背景颜色 = 0x0000FF;
	开放列表.insert(开放列表.begin(), 临时节点);
	do
	{
		最小F值 = 0;
		for (y = 0; y < 开放列表.size(); y++)
		{
			if (最小F值 == 0)
			{
				最小F值 = 开放列表[0].地图F点;
				最短编号 = y;
			}
			if (开放列表[y].地图F点 < 最小F值)
			{
				最小F值 = 开放列表[y].地图F点;
				最短编号 = y;
			}
		}
		临时节点 = 开放列表[最短编号];
		开放列表.erase(开放列表.begin() + 最短编号);
		关闭列表.insert(关闭列表.begin(), 临时节点);
		if (临时节点.当前坐标.X != 参_地图起点.X || 临时节点.当前坐标.Y != 参_地图起点.Y)
		{
			if (临时节点.当前坐标.X != 参_地图终点.X || 临时节点.当前坐标.Y != 参_地图终点.Y)
			{
				参_地图标签[临时节点.当前坐标.X][临时节点.当前坐标.Y].背景颜色 = 0x0080FF;
			}
		}
		for (y = 0; y < 关闭列表.size(); y++)
		{
			if (关闭列表[y].当前坐标.X == 参_地图终点.X && 关闭列表[y].当前坐标.Y == 参_地图终点.Y)
			{
				待检测节点 = 关闭列表[y];
				do
				{
					for (unsigned int x = 0; x < 关闭列表.size(); x++)
					{
						if (关闭列表[x].当前坐标.X == 待检测节点.最终坐标.X && 关闭列表[x].当前坐标.Y == 待检测节点.最终坐标.Y)
						{
							待检测节点 = 关闭列表[x];
							break;
						}
					}
					if (待检测节点.当前坐标.X != 参_地图起点.X || 待检测节点.当前坐标.Y != 参_地图起点.Y)
					{
						参_地图标签[待检测节点.当前坐标.X][待检测节点.当前坐标.Y].背景颜色 = 0x00D8D8;
						参_走法数组.insert(参_走法数组.begin(), 待检测节点.当前坐标);
					}
				} while (待检测节点.当前坐标.X != 参_地图起点.X || 待检测节点.当前坐标.Y != 参_地图起点.Y);
				参_走法数组.insert(参_走法数组.begin(), 参_地图起点);
				参_走法数组.insert(参_走法数组.end(), 参_地图终点);
				return;
			}
		}
		for (y = 0; y < 4; y++)
		{
			if (y == 0)
			{
				待检测坐标.X = 临时节点.当前坐标.X;
				待检测坐标.Y = 临时节点.当前坐标.Y - 1;
			}
			else if (y == 1)
			{
				待检测坐标.X = 临时节点.当前坐标.X - 1;
				待检测坐标.Y = 临时节点.当前坐标.Y;
			}
			else if (y == 2)
			{
				待检测坐标.X = 临时节点.当前坐标.X + 1;
				待检测坐标.Y = 临时节点.当前坐标.Y;
			}
			else
			{
				待检测坐标.X = 临时节点.当前坐标.X;
				待检测坐标.Y = 临时节点.当前坐标.Y + 1;
			}
			if (待检测坐标.X < 0 || 待检测坐标.X >(参_宽度 - 1) || 待检测坐标.Y < 0 || 待检测坐标.Y >(参_高度 - 1))
				continue;
			if (参_地图标签[待检测坐标.X][待检测坐标.Y].背景颜色 == 0x000000)
				continue;
			已存在关闭列表 = false;
			for (x = 0; x < 关闭列表.size(); x++)
			{
				if (关闭列表[x].当前坐标.X == 待检测坐标.X && 关闭列表[x].当前坐标.Y == 待检测坐标.Y)
				{
					已存在关闭列表 = true;
					break;
				}
			}
			if (已存在关闭列表)
				continue;
			已存在开放列表 = false;
			for (x = 0; x < 开放列表.size(); x++)
			{
				if (开放列表[x].当前坐标.X == 待检测坐标.X && 开放列表[x].当前坐标.Y == 待检测坐标.Y)
				{
					if (待检测坐标.X != 临时节点.当前坐标.X || 待检测坐标.Y != 临时节点.当前坐标.Y)
						预测G值 = 14;
					else
						预测G值 = 10;
					if (临时节点.地图G点 + 预测G值 < 开放列表[x].地图G点)
						开放列表[x].最终坐标 = 临时节点.当前坐标;
					已存在开放列表 = true;
					break;
				}
			}
			if (已存在开放列表 == false)
			{
				if (待检测坐标.X == 临时节点.当前坐标.X || 待检测坐标.Y == 临时节点.当前坐标.Y)
					预测G值 = 10;
				else
					预测G值 = 14;
				待检测节点.地图G点 = 临时节点.地图G点 + 预测G值;
				待检测节点.地图H点 = abs(参_地图终点.X - 待检测坐标.X) * 10 + abs(参_地图终点.Y - 待检测坐标.Y) * 10;
				待检测节点.地图F点 = 待检测节点.地图G点 + 待检测节点.地图H点;
				待检测节点.当前坐标 = 待检测坐标;
				待检测节点.最终坐标 = 临时节点.当前坐标;
				开放列表.insert(开放列表.begin(), 待检测节点);
			}
		}
	} while (开放列表.size() != 0);
}

DWORD 寻路_整理坐标(vector<坐标型> 参_模拟走法, vector<坐标型>& 参_真实走法)
{
	DWORD x, y;
	DWORD k = 0;
	坐标型 局_临时坐标;
	for (DWORD i = 0; i < 参_模拟走法.size(); i++)
	{
		x = (参_模拟走法[i].X + 2) % 3;
		y = (参_模拟走法[i].Y + 2) % 3;
		if (x == 0 && y == 0)
		{
			局_临时坐标.X = (参_模拟走法[i].X + 2) / 3 - 1;
			局_临时坐标.Y = (参_模拟走法[i].Y + 2) / 3 - 1;
			参_真实走法.insert(参_真实走法.begin() + k, 局_临时坐标);
			k++;
		}
	}
	return(k);
}

BOOL  寻路_判断方向(DWORD 参_通向, DWORD 参_方向)
{
	unsigned char 局_方向数组[4];
	unsigned char 局_方向集合[16][4] = { { 0, 0, 0, 0 }, { 0, 1, 0, 0 }, { 0, 0, 1, 0 }, { 0, 1, 1, 0 }, { 1, 0, 0, 0 }, { 1, 1, 0, 0 }, { 1, 0, 1, 0 }, { 1, 1, 1, 0 },
	{ 0, 0, 0, 1 }, { 0, 1, 0, 1 }, { 0, 0, 1, 1 }, { 0, 1, 1, 1 }, { 1, 0, 0, 1 }, { 1, 1, 0, 1 }, { 1, 0, 1, 1 }, { 1, 1, 1, 1 } };
	if (参_通向 >= 0 && 参_通向 <= 15)
		for (int i = 0; i < 4; i++)
			局_方向数组[i] = 局_方向集合[参_通向][i];
	else
		for (int i = 0; i < 4; i++)
			局_方向数组[i] = 0;
	if (局_方向数组[参_方向] == 1)
		return TRUE;
	else
		return FALSE;
}

DWORD 寻路_计算方向(坐标型 参_当前房间, 坐标型 参_下个房间)
{
	DWORD 局_X, 局_Y, 局_方向;
	局_X = 参_当前房间.X - 参_下个房间.X;
	局_Y = 参_当前房间.Y - 参_下个房间.Y;
	if (局_X == 0 && 局_Y == 0)
	{
		return 4;
	}

	if (局_X == 0)
	{
		if (局_Y == 1)
		{
			局_方向 = 2;
		}
		else
		{
			局_方向 = 3;
		}
	}
	else if (局_Y == 0)
	{
		if (局_X == 1)
		{
			局_方向 = 0;
		}
		else
		{
			局_方向 = 1;
		}
	}
	return 局_方向;
}




void 自动过图()
{
	if (全局_自动.参_已经进图 == false && 全局_自动.参_可以顺图 == false)
	{
		return;
	}
	if (是否在BOSS房() == true)
	{
		return;
	}
	
	if (是否开门() == false)
	{
		return;
	}
	
	地图数据 局_地图数据;
	局_地图数据 = 寻路_地图数据();
	if (sizeof(局_地图数据.地图走法) >= 2)
	{
			int 过图方向 = 寻路_计算方向(局_地图数据.地图走法[0], 局_地图数据.地图走法[1]);
			组包顺图(过图方向);
	}
}

